# WebSocket-Based Local Sandbox Architecture

**Status**: Implementation Plan
**Date**: 2025-11-24
**Goal**: Enable AI to execute commands on user's local machine via WebSocket communication

---

## Executive Summary

Design and implement a WebSocket-based local sandbox system that allows users to run AI commands on their local machine through Docker containers, with seamless fallback to E2B cloud sandboxes.

**Key Features:**
- Real-time bidirectional communication via WebSockets
- One-command setup for users: `npx hackerai-local --token TOKEN`
- Automatic switching between local and cloud execution
- Sub-10ms command delivery latency
- Docker container isolation with host networking for local network access

---

## Table of Contents

1. [System Architecture](#system-architecture)
2. [Technical Design](#technical-design)
3. [Implementation Plan](#implementation-plan)
4. [User Experience](#user-experience)
5. [Security Model](#security-model)
6. [Performance Specifications](#performance-specifications)
7. [Deployment Guide](#deployment-guide)

---

## System Architecture

### High-Level Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Browser/UI                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Local Sandbox Settings Tab                        â”‚ â”‚
â”‚  â”‚  - Real-time connection status                     â”‚ â”‚
â”‚  â”‚  - Token management (show/copy/regenerate)         â”‚ â”‚
â”‚  â”‚  - One-click setup instructions                    â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚ HTTP GET /api/local-sandbox/status
                        â”‚ (status checks every 3s)
                        â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Next.js Application Server                  â”‚
â”‚                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  WebSocket Server (ws://localhost:8080)            â”‚ â”‚
â”‚  â”‚                                                    â”‚ â”‚
â”‚  â”‚  Features:                                         â”‚ â”‚
â”‚  â”‚  - Persistent bidirectional connections            â”‚ â”‚
â”‚  â”‚  - Token-based authentication                      â”‚ â”‚
â”‚  â”‚  - Heartbeat monitoring (10s interval)             â”‚ â”‚
â”‚  â”‚  - Automatic disconnect detection                  â”‚ â”‚
â”‚  â”‚  - Command routing (userId â†’ WebSocket)            â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚               â”‚                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  ConnectionManager                                 â”‚ â”‚
â”‚  â”‚  - executeCommand(userId, cmd) â†’ Promise<Result>  â”‚ â”‚
â”‚  â”‚  - isConnected(userId) â†’ boolean                  â”‚ â”‚
â”‚  â”‚  - Manages pending command promises               â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚               â”‚                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  HybridSandboxManager                              â”‚ â”‚
â”‚  â”‚                                                    â”‚ â”‚
â”‚  â”‚  getSandbox():                                     â”‚ â”‚
â”‚  â”‚    if (connectionManager.isConnected(userId))      â”‚ â”‚
â”‚  â”‚      return WebSocketSandbox                       â”‚ â”‚
â”‚  â”‚    else                                            â”‚ â”‚
â”‚  â”‚      return E2BSandbox                             â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚               â”‚                   â”‚                      â”‚
â”‚      WebSocketSandbox             â”‚ E2BSandbox           â”‚
â”‚      (Local Docker)               â”‚ (Cloud Fallback)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â”‚ WebSocket (Port 8080)
                â”‚ Persistent Connection
                â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
         â”‚Local Client â”‚
         â”‚  (Node.js)  â”‚
         â”‚             â”‚
         â”‚ Features:   â”‚
         â”‚ - Auth      â”‚
         â”‚ - Heartbeat â”‚
         â”‚ - Reconnect â”‚
         â”‚ - Execute   â”‚
         â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                â”‚ docker exec
         â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
         â”‚   Docker    â”‚
         â”‚  Container  â”‚
         â”‚             â”‚
         â”‚ --network   â”‚
         â”‚    host     â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Convex Backend                         â”‚
â”‚                                                          â”‚
â”‚  Tables:                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ user_settings                                      â”‚ â”‚
â”‚  â”‚  - user_id (indexed)                               â”‚ â”‚
â”‚  â”‚  - local_sandbox_token: "hsb_..."                  â”‚ â”‚
â”‚  â”‚  - token_created_at: timestamp                     â”‚ â”‚
â”‚  â”‚  - updated_at: timestamp                           â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                          â”‚
â”‚  Queries/Mutations:                                      â”‚
â”‚  - getToken(userId): { token }                           â”‚
â”‚  - regenerateToken(userId): { token }                    â”‚
â”‚  - verifyToken(token): { valid, userId }                 â”‚
â”‚                                                          â”‚
â”‚  Note: WebSocket server manages active connections      â”‚
â”‚        in-memory. No connection tracking in Convex.      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Component Responsibilities

#### WebSocket Server
- Accept client connections on port 8080
- Authenticate via Convex token verification
- Maintain `userId â†’ WebSocket` mapping in memory
- Route commands to appropriate clients
- Monitor heartbeats and terminate dead connections
- Emit events for connection/disconnection

#### Connection Manager
- Provide promise-based command execution API
- Track pending commands with timeout handling
- Match command results to waiting promises
- Handle client disconnections gracefully

#### HybridSandboxManager
- Check connection status for each command
- Create WebSocketSandbox when local client connected
- Fallback to E2B Sandbox when local unavailable
- Transparent to AI tools (same interface)

#### WebSocketSandbox
- Implement E2B-compatible interface
- Translate E2B commands to WebSocket messages
- Handle file operations via shell commands
- Stream stdout/stderr to callbacks

#### Local Client
- Create and manage Docker container
- Authenticate with token
- Maintain WebSocket connection
- Execute commands in Docker via `docker exec`
- Send results back to server
- Auto-reconnect on disconnect

---

## Technical Design

### WebSocket Protocol

#### Message Types

**Client â†’ Server:**

```typescript
type ClientToServer =
  | {
      type: 'auth'
      token: string           // hsb_<64-hex-chars>
      containerId: string     // Docker container ID
      clientVersion: string   // Semver (e.g., "1.0.0")
    }
  | {
      type: 'result'
      commandId: string       // UUID from command message
      result: {
        stdout: string
        stderr: string
        exitCode: number
      }
      duration: number        // Execution time in ms
    }
  | {
      type: 'heartbeat'
      timestamp: number       // Unix timestamp (ms)
    }
```

**Server â†’ Client:**

```typescript
type ServerToClient =
  | {
      type: 'auth_success'
      userId: string
    }
  | {
      type: 'auth_failed'
      error: string
    }
  | {
      type: 'command'
      commandId: string       // UUID for tracking
      command: string         // Shell command to execute
      env?: Record<string, string>   // Environment variables
      cwd?: string           // Working directory
      timeout?: number       // Timeout in ms
    }
  | {
      type: 'heartbeat_ack'
      timestamp: number
    }
  | {
      type: 'shutdown'
      reason: string         // Why shutdown requested
    }
```

#### Connection Flow

```
1. Client connects to ws://localhost:8080

2. Client sends:
   { type: 'auth', token: 'hsb_...', containerId: 'abc123', clientVersion: '1.0.0' }

3. Server verifies token with Convex

4. If valid:
   Server sends: { type: 'auth_success', userId: 'user_123' }
   Server stores: clients.set('user_123', websocket)

   If invalid:
   Server sends: { type: 'auth_failed', error: 'Invalid token' }
   Server closes connection

5. Client starts heartbeat (every 5s):
   { type: 'heartbeat', timestamp: 1234567890 }

   Server responds:
   { type: 'heartbeat_ack', timestamp: 1234567890 }

6. AI requests command execution:
   connectionManager.executeCommand(userId, 'ls -la')

7. Server sends to client:
   { type: 'command', commandId: 'uuid-123', command: 'ls -la' }

8. Client executes in Docker, sends back:
   { type: 'result', commandId: 'uuid-123', result: { ... }, duration: 150 }

9. Server resolves promise, returns result to AI

10. Client disconnects or server detects dead heartbeat:
    - Server removes from clients Map
    - AI automatically falls back to E2B
```

#### Heartbeat Mechanism

**Purpose:** Detect network failures and crashed clients quickly

**Client side:**
```typescript
// Send heartbeat every 5 seconds
setInterval(() => {
  ws.send(JSON.stringify({ type: 'heartbeat', timestamp: Date.now() }))
}, 5000)
```

**Server side:**
```typescript
// Check every 10 seconds
setInterval(() => {
  clients.forEach((ws, userId) => {
    if (Date.now() - ws.lastHeartbeat > 15000) {
      // No heartbeat for 15s, connection dead
      ws.terminate()
      clients.delete(userId)
    }
  })
}, 10000)
```

**Detection time:** 10-15 seconds (vs TCP default of minutes)

---

## Implementation Plan

### Phase 1: WebSocket Server

#### File: `lib/websocket/protocol.ts`

```typescript
export type ClientToServer =
  | {
      type: 'auth'
      token: string
      containerId: string
      clientVersion: string
    }
  | {
      type: 'result'
      commandId: string
      result: {
        stdout: string
        stderr: string
        exitCode: number
      }
      duration: number
    }
  | {
      type: 'heartbeat'
      timestamp: number
    }

export type ServerToClient =
  | {
      type: 'auth_success'
      userId: string
    }
  | {
      type: 'auth_failed'
      error: string
    }
  | {
      type: 'command'
      commandId: string
      command: string
      env?: Record<string, string>
      cwd?: string
      timeout?: number
    }
  | {
      type: 'heartbeat_ack'
      timestamp: number
    }
  | {
      type: 'shutdown'
      reason: string
    }

export const PROTOCOL_VERSION = '1.0.0'
```

#### File: `lib/websocket/server.ts`

```typescript
import { WebSocketServer, WebSocket } from 'ws'
import { ConvexClient } from 'convex/browser'
import { api } from '@/convex/_generated/api'
import type { ClientToServer, ServerToClient } from './protocol'

interface AuthenticatedWebSocket extends WebSocket {
  userId?: string
  containerId?: string
  clientVersion?: string
  lastHeartbeat?: number
}

export class LocalSandboxWSServer {
  private wss: WebSocketServer
  private clients = new Map<string, AuthenticatedWebSocket>()
  private convex: ConvexClient
  private heartbeatInterval: NodeJS.Timeout

  constructor(port: number = 8080) {
    this.wss = new WebSocketServer({ port })
    this.convex = new ConvexClient(process.env.NEXT_PUBLIC_CONVEX_URL!)

    console.log(`âœ“ WebSocket server listening on port ${port}`)

    this.wss.on('connection', (ws: AuthenticatedWebSocket) => {
      this.handleConnection(ws)
    })

    // Check heartbeats every 10s
    this.heartbeatInterval = setInterval(() => {
      this.checkHeartbeats()
    }, 10000)
  }

  private handleConnection(ws: AuthenticatedWebSocket) {
    ws.lastHeartbeat = Date.now()

    ws.on('message', async (data) => {
      try {
        const message: ClientToServer = JSON.parse(data.toString())
        await this.handleMessage(ws, message)
      } catch (error) {
        console.error('Error handling message:', error)
        ws.close(1008, 'Invalid message format')
      }
    })

    ws.on('close', () => {
      this.handleDisconnect(ws)
    })

    ws.on('error', (error) => {
      console.error('WebSocket error:', error)
    })
  }

  private async handleMessage(
    ws: AuthenticatedWebSocket,
    message: ClientToServer
  ) {
    switch (message.type) {
      case 'auth':
        await this.handleAuth(ws, message)
        break

      case 'result':
        this.emit('command_result', {
          userId: ws.userId,
          commandId: message.commandId,
          result: message.result,
          duration: message.duration
        })
        break

      case 'heartbeat':
        ws.lastHeartbeat = Date.now()
        this.send(ws, { type: 'heartbeat_ack', timestamp: Date.now() })
        break
    }
  }

  private async handleAuth(
    ws: AuthenticatedWebSocket,
    message: Extract<ClientToServer, { type: 'auth' }>
  ) {
    // Verify token with Convex
    const result = await this.convex.query(api.localSandbox.verifyToken, {
      token: message.token
    })

    if (!result.valid) {
      this.send(ws, {
        type: 'auth_failed',
        error: 'Invalid or expired token'
      })
      ws.close(1008, 'Authentication failed')
      return
    }

    // Disconnect any existing connection for this user
    const existingWs = this.clients.get(result.userId!)
    if (existingWs && existingWs.readyState === WebSocket.OPEN) {
      this.send(existingWs, {
        type: 'shutdown',
        reason: 'New connection established'
      })
      existingWs.close(1000, 'Replaced by new connection')
    }

    // Authenticate this connection
    ws.userId = result.userId!
    ws.containerId = message.containerId
    ws.clientVersion = message.clientVersion
    this.clients.set(result.userId!, ws)

    this.send(ws, {
      type: 'auth_success',
      userId: result.userId!
    })

    console.log(`âœ“ Client authenticated: ${result.userId}`)
  }

  private handleDisconnect(ws: AuthenticatedWebSocket) {
    if (ws.userId) {
      this.clients.delete(ws.userId)
      console.log(`âœ— Client disconnected: ${ws.userId}`)
      this.emit('client_disconnected', ws.userId)
    }
  }

  private checkHeartbeats() {
    const now = Date.now()
    const HEARTBEAT_TIMEOUT = 15000 // 15 seconds

    this.clients.forEach((ws, userId) => {
      if (now - (ws.lastHeartbeat ?? 0) > HEARTBEAT_TIMEOUT) {
        console.warn(`Heartbeat timeout for ${userId}`)
        ws.terminate()
        this.clients.delete(userId)
      }
    })
  }

  // Public API
  sendCommand(
    userId: string,
    commandId: string,
    command: string,
    opts?: {
      env?: Record<string, string>
      cwd?: string
      timeout?: number
    }
  ): boolean {
    const ws = this.clients.get(userId)

    if (!ws || ws.readyState !== WebSocket.OPEN) {
      return false
    }

    this.send(ws, {
      type: 'command',
      commandId,
      command,
      ...opts
    })

    return true
  }

  isConnected(userId: string): boolean {
    const ws = this.clients.get(userId)
    return ws?.readyState === WebSocket.OPEN
  }

  private send(ws: WebSocket, message: ServerToClient) {
    if (ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify(message))
    }
  }

  // Simple event emitter
  private events = new Map<string, Function[]>()

  on(event: string, handler: Function) {
    if (!this.events.has(event)) {
      this.events.set(event, [])
    }
    this.events.get(event)!.push(handler)
  }

  private emit(event: string, data: any) {
    const handlers = this.events.get(event) ?? []
    handlers.forEach(handler => handler(data))
  }

  close() {
    clearInterval(this.heartbeatInterval)
    this.wss.close()
  }
}
```

#### File: `lib/websocket/connection-manager.ts`

```typescript
import { LocalSandboxWSServer } from './server'

interface CommandResult {
  stdout: string
  stderr: string
  exitCode: number
}

interface PendingCommand {
  commandId: string
  resolve: (result: CommandResult) => void
  reject: (error: Error) => void
  timeout: NodeJS.Timeout
}

export class ConnectionManager {
  private pendingCommands = new Map<string, PendingCommand>()

  constructor(private wsServer: LocalSandboxWSServer) {
    // Listen for command results
    wsServer.on('command_result', (data: any) => {
      this.handleCommandResult(data)
    })

    // Listen for disconnections
    wsServer.on('client_disconnected', (userId: string) => {
      this.handleClientDisconnect(userId)
    })
  }

  async executeCommand(
    userId: string,
    command: string,
    opts?: {
      env?: Record<string, string>
      cwd?: string
      timeout?: number
    }
  ): Promise<CommandResult> {
    const commandId = crypto.randomUUID()
    const timeout = opts?.timeout ?? 30000

    return new Promise((resolve, reject) => {
      // Set timeout
      const timeoutHandle = setTimeout(() => {
        this.pendingCommands.delete(commandId)
        reject(new Error(`Command timeout after ${timeout}ms`))
      }, timeout)

      // Store pending command
      this.pendingCommands.set(commandId, {
        commandId,
        resolve,
        reject,
        timeout: timeoutHandle
      })

      // Send command via WebSocket
      const sent = this.wsServer.sendCommand(userId, commandId, command, opts)

      if (!sent) {
        clearTimeout(timeoutHandle)
        this.pendingCommands.delete(commandId)
        reject(new Error('Client not connected'))
      }
    })
  }

  private handleCommandResult(data: {
    userId: string
    commandId: string
    result: CommandResult
    duration: number
  }) {
    const pending = this.pendingCommands.get(data.commandId)

    if (pending) {
      clearTimeout(pending.timeout)
      this.pendingCommands.delete(data.commandId)
      pending.resolve(data.result)
    }
  }

  private handleClientDisconnect(userId: string) {
    // Note: In production, track userId per command to reject only that user's commands
    // For simplicity, we accept that any pending commands will timeout naturally
  }

  isConnected(userId: string): boolean {
    return this.wsServer.isConnected(userId)
  }

  getServer(): LocalSandboxWSServer {
    return this.wsServer
  }
}
```

#### File: `lib/websocket/init.ts`

```typescript
import { LocalSandboxWSServer } from './server'
import { ConnectionManager } from './connection-manager'

let wsServer: LocalSandboxWSServer | null = null
let connectionManager: ConnectionManager | null = null

export function initWebSocketServer(): ConnectionManager {
  if (!wsServer) {
    const port = parseInt(process.env.WEBSOCKET_PORT ?? '8080')
    wsServer = new LocalSandboxWSServer(port)
    connectionManager = new ConnectionManager(wsServer)

    console.log(`âœ“ Local sandbox WebSocket initialized on port ${port}`)
  }

  return connectionManager!
}

export function getConnectionManager(): ConnectionManager {
  if (!connectionManager) {
    throw new Error('WebSocket server not initialized. Call initWebSocketServer() first.')
  }
  return connectionManager
}

// Cleanup on process exit
process.on('SIGTERM', () => {
  if (wsServer) {
    console.log('Closing WebSocket server...')
    wsServer.close()
  }
})
```

### Phase 2: Local Client

#### File: `scripts/local-sandbox-client.ts`

```typescript
#!/usr/bin/env node

import WebSocket from 'ws'
import { exec } from 'child_process'
import { promisify } from 'util'
import chalk from 'chalk'

const execAsync = promisify(exec)

interface Config {
  backendUrl: string
  token: string
  image: string
}

class LocalSandboxClient {
  private ws?: WebSocket
  private containerId?: string
  private reconnectAttempts = 0
  private heartbeatInterval?: NodeJS.Timeout
  private isShuttingDown = false

  constructor(private config: Config) {}

  async start() {
    console.log(chalk.blue('ğŸš€ Starting HackerAI local sandbox...'))

    // Check Docker
    try {
      await execAsync('docker --version')
    } catch {
      console.error(chalk.red('âŒ Docker not found. Please install Docker.'))
      process.exit(1)
    }

    // Create container
    this.containerId = await this.createContainer()
    console.log(chalk.green(`âœ“ Container: ${this.containerId.slice(0, 12)}`))

    // Connect WebSocket
    await this.connect()
  }

  private async createContainer(): Promise<string> {
    console.log(chalk.blue('Creating Docker container...'))

    const { stdout } = await execAsync(
      `docker run -d --network host ${this.config.image} tail -f /dev/null`
    )

    const containerId = stdout.trim()

    // Install common tools
    console.log(chalk.blue('Installing tools...'))
    await execAsync(
      `docker exec ${containerId} apt-get update -qq 2>/dev/null || true`
    )
    await execAsync(
      `docker exec ${containerId} apt-get install -y curl wget nmap git python3 python3-pip -qq 2>/dev/null || true`
    )

    return containerId
  }

  private async connect() {
    const wsUrl = this.config.backendUrl.replace(/^http/, 'ws') + ':8080'

    console.log(chalk.blue(`Connecting to ${wsUrl}...`))

    this.ws = new WebSocket(wsUrl)

    this.ws.on('open', () => {
      console.log(chalk.green('âœ“ Connected to backend'))
      this.reconnectAttempts = 0

      // Send auth message
      this.send({
        type: 'auth',
        token: this.config.token,
        containerId: this.containerId!,
        clientVersion: '1.0.0'
      })

      // Start heartbeat
      this.startHeartbeat()
    })

    this.ws.on('message', async (data) => {
      try {
        const message = JSON.parse(data.toString())
        await this.handleMessage(message)
      } catch (error) {
        console.error(chalk.red('Error handling message:'), error)
      }
    })

    this.ws.on('close', (code, reason) => {
      console.log(chalk.yellow(`âš ï¸  Disconnected: ${reason || code}`))
      this.stopHeartbeat()

      if (!this.isShuttingDown) {
        this.attemptReconnect()
      }
    })

    this.ws.on('error', (error) => {
      console.error(chalk.red('WebSocket error:'), error.message)
    })
  }

  private async handleMessage(message: any) {
    switch (message.type) {
      case 'auth_success':
        console.log(chalk.green.bold('ğŸ‰ Local sandbox is ready!'))
        console.log(chalk.gray(`User ID: ${message.userId}`))
        break

      case 'auth_failed':
        console.error(chalk.red('âŒ Authentication failed:'), message.error)
        console.error(chalk.yellow('Please regenerate your token in Settings'))
        this.isShuttingDown = true
        await this.cleanup()
        process.exit(1)
        break

      case 'command':
        await this.executeCommand(message)
        break

      case 'shutdown':
        console.log(chalk.yellow(`Server requested shutdown: ${message.reason}`))
        this.isShuttingDown = true
        await this.cleanup()
        process.exit(0)
        break

      case 'heartbeat_ack':
        // Heartbeat acknowledged
        break
    }
  }

  private async executeCommand(message: any) {
    const { commandId, command, env, cwd, timeout } = message
    const startTime = Date.now()

    console.log(chalk.cyan(`â–¶ Executing: ${command}`))

    try {
      // Build command with env vars and cwd
      let fullCommand = command

      if (cwd) {
        fullCommand = `cd ${cwd} && ${fullCommand}`
      }

      if (env) {
        const envString = Object.entries(env)
          .map(([k, v]) => `export ${k}="${v}"`)
          .join('; ')
        fullCommand = `${envString}; ${fullCommand}`
      }

      // Execute in container
      const { stdout, stderr } = await execAsync(
        `docker exec ${this.containerId} bash -c "${fullCommand.replace(/"/g, '\\"')}"`,
        { timeout: timeout ?? 30000 }
      ).catch(error => ({
        stdout: error.stdout || '',
        stderr: error.stderr || error.message,
        code: error.code || 1
      }))

      const duration = Date.now() - startTime

      // Send result back
      this.send({
        type: 'result',
        commandId,
        result: {
          stdout: stdout || '',
          stderr: stderr || '',
          exitCode: 0
        },
        duration
      })

      console.log(chalk.green(`âœ“ Command completed in ${duration}ms`))

    } catch (error: any) {
      const duration = Date.now() - startTime

      this.send({
        type: 'result',
        commandId,
        result: {
          stdout: '',
          stderr: error.message,
          exitCode: 1
        },
        duration
      })

      console.log(chalk.red(`âœ— Command failed: ${error.message}`))
    }
  }

  private startHeartbeat() {
    this.heartbeatInterval = setInterval(() => {
      this.send({ type: 'heartbeat', timestamp: Date.now() })
    }, 5000) // Every 5 seconds
  }

  private stopHeartbeat() {
    if (this.heartbeatInterval) {
      clearInterval(this.heartbeatInterval)
      this.heartbeatInterval = undefined
    }
  }

  private attemptReconnect() {
    if (this.isShuttingDown) return

    this.reconnectAttempts++
    const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000)

    console.log(
      chalk.yellow(
        `Reconnecting in ${delay / 1000}s (attempt ${this.reconnectAttempts})...`
      )
    )

    setTimeout(() => {
      this.connect()
    }, delay)
  }

  private send(message: any) {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify(message))
    }
  }

  async cleanup() {
    console.log(chalk.blue('\nğŸ§¹ Cleaning up...'))

    this.stopHeartbeat()

    if (this.ws) {
      this.ws.close()
    }

    if (this.containerId) {
      try {
        await execAsync(`docker rm -f ${this.containerId}`)
        console.log(chalk.green('âœ“ Container removed'))
      } catch (error) {
        console.error(chalk.red('Error removing container:'), error)
      }
    }
  }
}

// Parse command-line arguments
const args = process.argv.slice(2)
const getArg = (flag: string) => {
  const index = args.indexOf(flag)
  return index >= 0 ? args[index + 1] : undefined
}

const config = {
  backendUrl:
    getArg('--backend-url') || process.env.BACKEND_URL || 'http://localhost:3000',
  token: getArg('--token') || process.env.HACKERAI_TOKEN || '',
  image: getArg('--image') || process.env.DOCKER_IMAGE || 'ubuntu:latest'
}

if (!config.token) {
  console.error(chalk.red('âŒ No authentication token provided'))
  console.error(chalk.yellow('Usage: npx hackerai-local --token YOUR_TOKEN'))
  console.error(chalk.yellow('Or set HACKERAI_TOKEN environment variable'))
  process.exit(1)
}

const client = new LocalSandboxClient(config)

// Graceful shutdown
process.on('SIGINT', async () => {
  console.log(chalk.yellow('\nğŸ›‘ Shutting down...'))
  client['isShuttingDown'] = true
  await client.cleanup()
  process.exit(0)
})

process.on('SIGTERM', async () => {
  client['isShuttingDown'] = true
  await client.cleanup()
  process.exit(0)
})

client.start().catch(error => {
  console.error(chalk.red('Fatal error:'), error)
  process.exit(1)
})
```

### Phase 3: Sandbox Integration

#### File: `lib/ai/tools/utils/websocket-sandbox.ts`

```typescript
import { EventEmitter } from 'events'
import type { ConnectionManager } from '@/lib/websocket/connection-manager'

/**
 * WebSocket-based sandbox that implements E2B-compatible interface
 * Allows seamless switching between local and cloud execution
 */
export class WebSocketSandbox extends EventEmitter {
  constructor(
    private userId: string,
    private connectionManager: ConnectionManager
  ) {
    super()
  }

  // E2B-compatible interface: commands.run()
  commands = {
    run: async (command: string, opts?: {
      envVars?: Record<string, string>
      cwd?: string
      timeoutMs?: number
      background?: boolean
      onStdout?: (data: string) => void
      onStderr?: (data: string) => void
    }) => {
      if (opts?.background) {
        // Background commands not supported in local mode yet
        throw new Error('Background commands not supported in local sandbox')
      }

      // Execute command via WebSocket
      const result = await this.connectionManager.executeCommand(
        this.userId,
        command,
        {
          env: opts?.envVars,
          cwd: opts?.cwd ?? '/home/user',
          timeout: opts?.timeoutMs ?? 30000
        }
      )

      // Stream output if handlers provided
      if (opts?.onStdout && result.stdout) {
        opts.onStdout(result.stdout)
      }
      if (opts?.onStderr && result.stderr) {
        opts.onStderr(result.stderr)
      }

      return {
        stdout: result.stdout || '',
        stderr: result.stderr || '',
        exitCode: result.exitCode ?? 0
      }
    }
  }

  // E2B-compatible interface: files operations
  files = {
    write: async (path: string, content: string | Buffer) => {
      const contentStr = typeof content === 'string'
        ? content
        : content.toString('base64')

      const command = typeof content === 'string'
        ? `cat > ${path} <<'EOF'\n${contentStr}\nEOF`
        : `echo "${contentStr}" | base64 -d > ${path}`

      await this.commands.run(command)
    },

    read: async (path: string): Promise<string> => {
      const result = await this.commands.run(`cat ${path}`)
      if (result.exitCode !== 0) {
        throw new Error(`Failed to read file: ${result.stderr}`)
      }
      return result.stdout
    },

    remove: async (path: string) => {
      await this.commands.run(`rm -rf ${path}`)
    },

    list: async (path: string = '/') => {
      const result = await this.commands.run(`find ${path} -maxdepth 1 -type f`)
      if (result.exitCode !== 0) return []

      return result.stdout
        .split('\n')
        .filter(Boolean)
        .map(name => ({ name }))
    }
  }

  // E2B-compatible interface: getHost()
  getHost(port: number): string {
    return `localhost:${port}`
  }

  // E2B-compatible interface: close()
  async close(): Promise<void> {
    // Connection persists, just emit close event
    this.emit('close')
  }
}
```

#### File: `lib/ai/tools/utils/hybrid-sandbox-manager.ts`

```typescript
import { Sandbox } from '@e2b/code-interpreter'
import type { SandboxManager } from '@/types'
import { WebSocketSandbox } from './websocket-sandbox'
import { getConnectionManager } from '@/lib/websocket/init'

/**
 * Hybrid sandbox manager that automatically switches between
 * local WebSocket sandbox and E2B cloud sandbox based on connection status
 */
export class HybridSandboxManager implements SandboxManager {
  private sandbox: Sandbox | WebSocketSandbox | null = null
  private isLocal = false

  constructor(
    private userID: string,
    private setSandboxCallback: (sandbox: any) => void,
    initialSandbox?: Sandbox | null
  ) {
    this.sandbox = initialSandbox || null
  }

  async getSandbox(): Promise<{ sandbox: Sandbox | WebSocketSandbox }> {
    const connectionManager = getConnectionManager()

    // Check if local client is connected
    const localConnected = connectionManager.isConnected(this.userID)

    if (localConnected) {
      // Use local WebSocket sandbox
      if (!this.isLocal || !this.sandbox) {
        console.log(`[${this.userID}] Switching to local sandbox`)
        this.sandbox = new WebSocketSandbox(this.userID, connectionManager)
        this.isLocal = true
        this.setSandboxCallback(this.sandbox)
      }

      return { sandbox: this.sandbox }
    } else {
      // Fall back to E2B
      if (this.isLocal || !this.sandbox) {
        console.log(`[${this.userID}] Switching to E2B sandbox`)
        this.sandbox = await Sandbox.create({
          apiKey: process.env.E2B_API_KEY!,
          timeoutMs: 15 * 60 * 1000
        })
        this.isLocal = false
        this.setSandboxCallback(this.sandbox)
      }

      return { sandbox: this.sandbox as Sandbox }
    }
  }

  setSandbox(sandbox: Sandbox | WebSocketSandbox): void {
    this.sandbox = sandbox
    this.setSandboxCallback(sandbox)
  }
}
```

#### Update: `lib/ai/tools/index.ts`

```typescript
// Change import
import { HybridSandboxManager } from './utils/hybrid-sandbox-manager'

export const createTools = (
  userID: string,
  writer: UIMessageStreamWriter,
  mode: ChatMode = "agent",
  userLocation: Geo,
  initialTodos?: Todo[],
  memoryEnabled: boolean = true,
  isTemporary: boolean = false,
  assistantMessageId?: string,
  subscription: "free" | "pro" | "team" | "ultra" = "free",
) => {
  let sandbox: Sandbox | null = null

  // Use HybridSandboxManager instead of DefaultSandboxManager
  const sandboxManager = new HybridSandboxManager(
    userID,
    (newSandbox) => {
      sandbox = newSandbox
    },
    sandbox
  )

  // ... rest unchanged
}
```

### Phase 4: Convex Backend

#### Update: `convex/schema.ts`

```typescript
// Add this table to existing schema

user_settings: defineTable({
  user_id: v.string(),
  local_sandbox_token: v.optional(v.string()),
  token_created_at: v.optional(v.number()),
  updated_at: v.number(),
})
  .index('by_user_id', ['user_id'])
  .index('by_token', ['local_sandbox_token'])
```

#### File: `convex/localSandbox.ts`

```typescript
import { v } from 'convex/values'
import { mutation, query } from './_generated/server'

function generateToken(): string {
  const chars = 'abcdefghijklmnopqrstuvwxyz0123456789'
  let token = 'hsb_'
  for (let i = 0; i < 64; i++) {
    token += chars[Math.floor(Math.random() * chars.length)]
  }
  return token
}

export const getToken = mutation({
  args: { userId: v.string() },
  handler: async (ctx, { userId }) => {
    const existing = await ctx.db
      .query('user_settings')
      .withIndex('by_user_id', q => q.eq('user_id', userId))
      .first()

    if (existing?.local_sandbox_token) {
      return { token: existing.local_sandbox_token }
    }

    const token = generateToken()

    if (existing) {
      await ctx.db.patch(existing._id, {
        local_sandbox_token: token,
        token_created_at: Date.now(),
        updated_at: Date.now()
      })
    } else {
      await ctx.db.insert('user_settings', {
        user_id: userId,
        local_sandbox_token: token,
        token_created_at: Date.now(),
        updated_at: Date.now()
      })
    }

    return { token }
  }
})

export const regenerateToken = mutation({
  args: { userId: v.string() },
  handler: async (ctx, { userId }) => {
    const token = generateToken()

    const existing = await ctx.db
      .query('user_settings')
      .withIndex('by_user_id', q => q.eq('user_id', userId))
      .first()

    if (existing) {
      await ctx.db.patch(existing._id, {
        local_sandbox_token: token,
        token_created_at: Date.now(),
        updated_at: Date.now()
      })
    } else {
      await ctx.db.insert('user_settings', {
        user_id: userId,
        local_sandbox_token: token,
        token_created_at: Date.now(),
        updated_at: Date.now()
      })
    }

    return { token }
  }
})

export const verifyToken = query({
  args: { token: v.string() },
  handler: async (ctx, { token }) => {
    const settings = await ctx.db
      .query('user_settings')
      .withIndex('by_token', q => q.eq('local_sandbox_token', token))
      .first()

    return settings
      ? { valid: true, userId: settings.user_id }
      : { valid: false, userId: null }
  }
})
```

### Phase 5: UI Components

#### File: `app/components/LocalSandboxTab.tsx`

```typescript
'use client'

import { useState, useEffect } from 'react'
import { useMutation, useQuery } from 'convex/react'
import { api } from '@/convex/_generated/api'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Copy, Eye, EyeOff, RefreshCw, Circle } from 'lucide-react'
import { toast } from 'sonner'
import { useUser } from '@workos-inc/authkit-nextjs'

export function LocalSandboxTab() {
  const { user } = useUser()
  const [showToken, setShowToken] = useState(false)
  const [isConnected, setIsConnected] = useState(false)

  const tokenResult = useQuery(
    api.localSandbox.getToken,
    user ? { userId: user.id } : 'skip'
  )
  const regenerate = useMutation(api.localSandbox.regenerateToken)

  const token = tokenResult?.token

  // Poll connection status every 3 seconds
  useEffect(() => {
    const check = async () => {
      try {
        const res = await fetch('/api/local-sandbox/status')
        const { connected } = await res.json()
        setIsConnected(connected)
      } catch {
        setIsConnected(false)
      }
    }

    check()
    const interval = setInterval(check, 3000)
    return () => clearInterval(interval)
  }, [])

  return (
    <div className="space-y-6 p-6">
      {/* Connection Status */}
      <div className="flex items-center gap-3 p-4 border rounded">
        <Circle
          className={`h-3 w-3 ${
            isConnected
              ? 'fill-green-500 text-green-500'
              : 'fill-gray-400 text-gray-400'
          }`}
        />
        <div>
          <div className="font-medium">
            {isConnected ? 'Local Sandbox Connected' : 'Cloud Sandbox (E2B)'}
          </div>
          <div className="text-sm text-muted-foreground">
            {isConnected
              ? 'Commands running on your local machine'
              : 'Run the local client to enable local execution'}
          </div>
        </div>
      </div>

      {/* Quick Setup */}
      <div className="space-y-4">
        <h3 className="font-semibold">Quick Setup</h3>
        <div className="space-y-2">
          <label className="text-sm font-medium">
            Copy and run this command:
          </label>
          <div className="flex gap-2">
            <Input
              value={
                token
                  ? `npx hackerai-local --token ${showToken ? token : 'â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢'}`
                  : 'Loading...'
              }
              readOnly
              className="font-mono text-sm"
            />
            <Button
              variant="outline"
              size="icon"
              onClick={() => {
                if (token) {
                  navigator.clipboard.writeText(
                    `npx hackerai-local --token ${token}`
                  )
                  toast.success('Command copied to clipboard')
                }
              }}
              disabled={!token}
            >
              <Copy className="h-4 w-4" />
            </Button>
          </div>
        </div>
        <div className="text-sm text-muted-foreground space-y-1">
          <p>1. Paste command in your terminal</p>
          <p>2. Wait for "ğŸ‰ Local sandbox is ready!"</p>
          <p>3. Start using the app - all commands now run locally</p>
        </div>
      </div>

      {/* Token Management */}
      <div className="space-y-4 border-t pt-4">
        <h3 className="font-semibold">Authentication Token</h3>
        <div className="space-y-2">
          <div className="flex gap-2">
            <Input
              type={showToken ? 'text' : 'password'}
              value={token || 'Loading...'}
              readOnly
              className="font-mono text-sm"
            />
            <Button
              variant="outline"
              size="icon"
              onClick={() => setShowToken(!showToken)}
              disabled={!token}
            >
              {showToken ? (
                <EyeOff className="h-4 w-4" />
              ) : (
                <Eye className="h-4 w-4" />
              )}
            </Button>
            <Button
              variant="outline"
              size="icon"
              onClick={() => {
                if (token) {
                  navigator.clipboard.writeText(token)
                  toast.success('Token copied to clipboard')
                }
              }}
              disabled={!token}
            >
              <Copy className="h-4 w-4" />
            </Button>
          </div>
          <div className="flex justify-end">
            <Button
              variant="outline"
              size="sm"
              onClick={async () => {
                if (user) {
                  await regenerate({ userId: user.id })
                  toast.success('Token regenerated successfully')
                  setShowToken(false)
                }
              }}
              disabled={!token}
            >
              <RefreshCw className="h-4 w-4 mr-2" />
              Regenerate Token
            </Button>
          </div>
        </div>
        <p className="text-sm text-muted-foreground">
          âš ï¸ Keep this token secret. Regenerating will disconnect any running clients.
        </p>
      </div>

      {/* Advanced Options */}
      <div className="space-y-4 border-t pt-4">
        <h3 className="font-semibold">Advanced Options</h3>
        <div className="space-y-3 text-sm">
          <div>
            <div className="font-medium">Custom Docker Image</div>
            <code className="text-xs bg-muted p-2 rounded mt-1 block">
              npx hackerai-local --token {showToken && token ? token : 'â€¢â€¢â€¢â€¢'}
              --image kalilinux/kali-rolling
            </code>
          </div>
          <div>
            <div className="font-medium">Custom Backend URL</div>
            <code className="text-xs bg-muted p-2 rounded mt-1 block">
              npx hackerai-local --token {showToken && token ? token : 'â€¢â€¢â€¢â€¢'}
              --backend-url https://your-domain.com
            </code>
          </div>
        </div>
      </div>

      {/* Security Warning */}
      <div className="p-4 bg-yellow-50 dark:bg-yellow-950 border border-yellow-200 dark:border-yellow-800 rounded">
        <div className="text-sm space-y-2">
          <div className="font-semibold text-yellow-900 dark:text-yellow-100">
            Security Notice
          </div>
          <ul className="list-disc list-inside space-y-1 text-yellow-800 dark:text-yellow-200">
            <li>The AI will have access to your local network</li>
            <li>Commands run in an isolated Docker container</li>
            <li>Container uses host networking (--network host)</li>
            <li>Stop anytime with Ctrl+C</li>
          </ul>
        </div>
      </div>
    </div>
  )
}
```

#### Update: `app/components/SettingsDialog.tsx`

```typescript
import { Server } from 'lucide-react'
import { LocalSandboxTab } from './LocalSandboxTab'

// Add to tabs array
const baseTabs = [
  { id: "Personalization", label: "Personalization", icon: Settings },
  { id: "Security", label: "Security", icon: Shield },
  { id: "Data controls", label: "Data controls", icon: Database },
  { id: "Local Sandbox", label: "Local Sandbox", icon: Server }, // ADD THIS
  { id: "Agents", label: "Agents", icon: Infinity },
]

// Add to render section
{activeTab === "Local Sandbox" && <LocalSandboxTab />}
```

#### File: `app/api/local-sandbox/status/route.ts`

```typescript
import { authkit } from '@workos-inc/authkit-nextjs'
import { getConnectionManager } from '@/lib/websocket/init'

export async function GET(req: Request) {
  try {
    const { session } = await authkit(req)
    if (!session) {
      return Response.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const connectionManager = getConnectionManager()
    const connected = connectionManager.isConnected(session.user.id)

    return Response.json({ connected })
  } catch (error) {
    return Response.json({ connected: false })
  }
}
```

### Phase 6: Bootstrap & Configuration

#### Initialize WebSocket Server

Add to `next.config.js` or create initialization script:

```typescript
// lib/websocket/bootstrap.ts

import { initWebSocketServer } from './init'

// Auto-initialize on server start
if (typeof window === 'undefined') {
  initWebSocketServer()
}
```

Or in `next.config.js`:

```javascript
// next.config.js

module.exports = {
  webpack: (config, { isServer }) => {
    if (isServer) {
      // Initialize WebSocket server on build
      require('./lib/websocket/init').initWebSocketServer()
    }
    return config
  }
}
```

#### Package Dependencies

```json
{
  "dependencies": {
    "ws": "^8.18.0",
    "chalk": "^5.6.2"
  },
  "devDependencies": {
    "@types/ws": "^8.5.10"
  },
  "scripts": {
    "local-sandbox": "tsx scripts/local-sandbox-client.ts"
  }
}
```

#### Environment Variables

```env
# .env.local

# WebSocket server port
WEBSOCKET_PORT=8080

# Convex (already configured)
NEXT_PUBLIC_CONVEX_URL=https://...
CONVEX_DEPLOYMENT=...

# E2B (already configured)
E2B_API_KEY=...
```

---

## User Experience

### First-Time Setup

```
1. User opens app â†’ Settings â†’ Local Sandbox

2. Sees status:
   âšª Cloud Sandbox (E2B)
   Run the local client to enable local execution

3. User clicks "Copy" button next to command:
   npx hackerai-local --token hsb_abc123def456...

4. User pastes in terminal, presses Enter

5. Client output:
   ğŸš€ Starting HackerAI local sandbox...
   âœ“ Docker is available
   Creating Docker container...
   âœ“ Container: a1b2c3d4e5f6
   Installing tools...
   Connecting to ws://localhost:8080...
   âœ“ Connected to backend
   âœ“ Client authenticated: user_abc123
   ğŸ‰ Local sandbox is ready!

6. UI automatically updates (within 3 seconds):
   ğŸŸ¢ Local Sandbox Connected
   Commands running on your local machine

7. User starts chatting - all commands execute locally!
```

### Daily Workflow

```
Start of day:
1. Open terminal
2. Run: npx hackerai-local --token TOKEN
3. See: ğŸ‰ Local sandbox is ready!
4. Use app normally

End of day:
1. Press Ctrl+C in terminal
2. See: ğŸ§¹ Cleaning up...
      âœ“ Container removed
3. Client exits
4. UI shows: âšª Cloud Sandbox (E2B)
```

### Command Execution (User Perspective)

```
User: "Scan my local network for devices"

Behind the scenes:
T+0ms:    AI tool calls sandbox.commands.run("nmap -sn 192.168.1.0/24")
T+5ms:    WebSocket sends command to client
T+10ms:   Client receives and starts execution
T+2500ms: nmap completes
T+2505ms: Client sends result via WebSocket
T+2510ms: AI receives result
T+2515ms: AI presents findings to user

Total: 2.5 seconds (execution time) + 15ms (WebSocket overhead)
```

---

## Security Model

### Authentication Flow

```
1. User generates token in UI
   â†’ Convex stores: { user_id: "user_123", local_sandbox_token: "hsb_..." }

2. Client connects with token
   â†’ WebSocket server queries Convex to verify

3. Server validates and maps connection
   â†’ clients.set("user_123", websocket)

4. All subsequent commands authenticated by connection
   â†’ Command only sent to websocket for that userId
```

### Authorization

- **One connection per user**: New connection disconnects old one
- **User isolation**: Commands only routed to user's own container
- **No cross-user access**: Impossible due to userId mapping

### Network Security

**Client Side:**
- Docker container with `--network host`
- Can access local network (intentional feature)
- Filesystem isolated within container
- User must explicitly run client

**Server Side:**
- WebSocket on port 8080
- Token-based authentication
- Connection validation on every message
- Automatic disconnect on invalid auth

**Production Hardening:**
```typescript
// Use WSS (TLS) in production
const wss = new WebSocketServer({
  server: httpsServer,
  verifyClient: (info) => {
    // Origin validation
    const origin = info.origin
    return allowedOrigins.includes(origin)
  }
})
```

### Docker Container Isolation

```bash
# What's isolated:
- Filesystem (container's own filesystem)
- Process namespace (can't see host processes)
- User namespace (root in container â‰  root on host)

# What's NOT isolated:
- Network (--network host for local access)
- This is a security trade-off for functionality
```

---

## Performance Specifications

### Latency Targets

```
Command delivery:     < 10ms   (WebSocket send)
Result return:        < 10ms   (WebSocket send)
Total overhead:       < 20ms   (excluding command execution)
Disconnect detection: 10-15s   (heartbeat timeout)
Reconnection:         1-30s    (exponential backoff)
```

### Resource Requirements

**Server (per 100 users):**
```
CPU:     +0.5 cores (idle), +2 cores (active)
Memory:  +500MB (connections + buffers)
Network: +100 KB/s (heartbeats + commands)
```

**Client:**
```
CPU:     0.5-1 core per container
Memory:  512MB-1GB per container
Disk:    2GB for Docker image + layers
Network: Minimal (command text + results)
```

### Scalability Limits

```
Single server capacity:
- Max concurrent connections: 10,000
- Max commands/minute: 100,000
- Max message size: 10MB

Per-user limits:
- Max concurrent commands: 10
- Command timeout: 30s default, 10min max
```

### Timeout Configuration

```typescript
// Client heartbeat
HEARTBEAT_INTERVAL = 5000ms      // Send every 5s

// Server heartbeat check
HEARTBEAT_CHECK_INTERVAL = 10000ms  // Check every 10s
HEARTBEAT_TIMEOUT = 15000ms         // Consider dead after 15s

// Command execution
DEFAULT_COMMAND_TIMEOUT = 30000ms   // 30s
MAX_COMMAND_TIMEOUT = 600000ms      // 10min

// Reconnection
RECONNECT_BASE_DELAY = 1000ms       // Start at 1s
RECONNECT_MAX_DELAY = 30000ms       // Cap at 30s
RECONNECT_BACKOFF_FACTOR = 2        // Exponential
```

---

## Deployment Guide

### Development Setup

```bash
# Install dependencies
npm install ws chalk @types/ws

# Start Next.js dev server (includes WebSocket)
npm run dev

# In another terminal, start local client
npm run local-sandbox -- --token test-token
```

### Production Deployment

#### 1. Environment Variables

```env
# Production .env
WEBSOCKET_PORT=8080
NEXT_PUBLIC_CONVEX_URL=https://production.convex.cloud
E2B_API_KEY=e2b_prod_key
```

#### 2. Server Configuration

```typescript
// lib/websocket/init.ts production config

export function initWebSocketServer(): ConnectionManager {
  if (!wsServer) {
    const port = parseInt(process.env.WEBSOCKET_PORT ?? '8080')
    const useSSL = process.env.NODE_ENV === 'production'

    if (useSSL) {
      // Use WSS in production
      const httpsServer = https.createServer({
        cert: fs.readFileSync(process.env.SSL_CERT_PATH!),
        key: fs.readFileSync(process.env.SSL_KEY_PATH!)
      })

      wsServer = new LocalSandboxWSServer(port, { server: httpsServer })
    } else {
      wsServer = new LocalSandboxWSServer(port)
    }

    connectionManager = new ConnectionManager(wsServer)
  }
  return connectionManager!
}
```

#### 3. Firewall Rules

```bash
# Allow WebSocket port
sudo ufw allow 8080/tcp
```

#### 4. Monitoring

```typescript
// Add to WebSocket server
setInterval(() => {
  console.log(`Active connections: ${this.clients.size}`)
  console.log(`Pending commands: ${connectionManager.pendingCommands.size}`)
}, 60000)
```

### Testing

#### Unit Tests

```bash
npm test -- websocket-server.test.ts
npm test -- connection-manager.test.ts
npm test -- websocket-sandbox.test.ts
```

#### Integration Tests

```bash
npm test -- local-sandbox-integration.test.ts
```

#### Manual Testing Checklist

- [ ] Client connects successfully
- [ ] Auth with valid token succeeds
- [ ] Auth with invalid token fails
- [ ] Commands execute and return results
- [ ] Heartbeat keeps connection alive
- [ ] Disconnect detected within 15s
- [ ] Client reconnects after network failure
- [ ] Token regeneration disconnects old client
- [ ] UI shows correct connection status
- [ ] E2B fallback works when client stops
- [ ] Large command output handled correctly
- [ ] Command timeout works correctly

---

## Appendix

### File Structure

```
lib/
â”œâ”€â”€ websocket/
â”‚   â”œâ”€â”€ protocol.ts           # Message type definitions
â”‚   â”œâ”€â”€ server.ts             # WebSocket server implementation
â”‚   â”œâ”€â”€ connection-manager.ts # Command execution & promises
â”‚   â”œâ”€â”€ init.ts               # Singleton initialization
â”‚   â””â”€â”€ bootstrap.ts          # Auto-start configuration
â”œâ”€â”€ ai/
â”‚   â””â”€â”€ tools/
â”‚       â”œâ”€â”€ index.ts          # Update to use HybridSandboxManager
â”‚       â””â”€â”€ utils/
â”‚           â”œâ”€â”€ websocket-sandbox.ts      # E2B-compatible wrapper
â”‚           â””â”€â”€ hybrid-sandbox-manager.ts # Auto-switching logic

convex/
â”œâ”€â”€ schema.ts                 # Add user_settings table
â””â”€â”€ localSandbox.ts          # Token management mutations/queries

app/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ LocalSandboxTab.tsx  # Settings UI component
â”‚   â””â”€â”€ SettingsDialog.tsx   # Add Local Sandbox tab
â””â”€â”€ api/
    â””â”€â”€ local-sandbox/
        â””â”€â”€ status/
            â””â”€â”€ route.ts      # Connection status endpoint

scripts/
â””â”€â”€ local-sandbox-client.ts  # Standalone client application

docs/
â””â”€â”€ WEBSOCKET_ARCHITECTURE.md # This document
```

### Dependencies

```json
{
  "dependencies": {
    "ws": "^8.18.0",
    "chalk": "^5.6.2"
  },
  "devDependencies": {
    "@types/ws": "^8.5.10"
  },
  "scripts": {
    "local-sandbox": "tsx scripts/local-sandbox-client.ts"
  }
}
```

### Configuration Summary

| Setting | Default | Description |
|---------|---------|-------------|
| WEBSOCKET_PORT | 8080 | WebSocket server port |
| Heartbeat interval | 5s | Client sends ping |
| Heartbeat timeout | 15s | Server considers dead |
| Command timeout | 30s | Default max execution time |
| Max command timeout | 10min | Hard limit |
| Reconnect base delay | 1s | Initial retry delay |
| Reconnect max delay | 30s | Cap on retry delay |
| Max message size | 10MB | Per WebSocket message |

---

## Next Steps

1. **Review this architecture** for approval
2. **Install dependencies**: `npm install ws chalk @types/ws`
3. **Implement Phase 1**: WebSocket server
4. **Implement Phase 2**: Local client
5. **Test connection flow**: Client connects, authenticates, executes command
6. **Implement Phase 3**: Sandbox integration
7. **Implement Phase 4**: Convex backend
8. **Implement Phase 5**: UI components
9. **End-to-end testing**: Full user workflow
10. **Deploy to production**

---

**Document Version**: 2.0.0
**Last Updated**: 2025-11-24
**Status**: Ready for Implementation
