import { stripe } from "../stripe";
import { workos } from "../workos";
import { getUserIDAndPro } from "@/lib/auth/get-user-id";
import { NextRequest, NextResponse } from "next/server";

export const POST = async (req: NextRequest) => {
  try {
    // Get user ID and subscription status
    const { userId, subscription } = await getUserIDAndPro(req);

    // Only allow migration if user is on free tier
    if (subscription !== "free") {
      return NextResponse.json(
        {
          error: "Migration not allowed",
          message: "You must be on the free tier to migrate from PentestGPT",
        },
        { status: 400 },
      );
    }

    // Get user details
    const user = await workos.userManagement.getUser(userId);

    // Search for active PentestGPT subscriptions for this email
    const customers = await stripe.customers.list({
      email: user.email,
      limit: 100,
    });

    let pentestGPTSubscription = null;
    let pentestGPTCustomer = null;

    // Look for customers from old PentestGPT system and active subscriptions
    // Old system used firebaseUID or userId in metadata, new system uses workOSOrganizationId
    for (const customer of customers.data) {
      // Only consider customers that don't have the new system metadata (workOSOrganizationId)
      const hasNewMetadata = customer.metadata?.workOSOrganizationId;

      if (!hasNewMetadata) {
        // Check for active subscriptions
        const subscriptions = await stripe.subscriptions.list({
          customer: customer.id,
          status: "active",
          limit: 1,
          expand: [
            "data.default_payment_method",
            "data.latest_invoice.payment_intent.payment_method",
            "data.items",
          ],
        });

        if (subscriptions.data.length > 0) {
          pentestGPTSubscription = subscriptions.data[0];
          pentestGPTCustomer = customer;
          break;
        }
      }
    }

    // If no active PentestGPT subscription found
    if (!pentestGPTSubscription || !pentestGPTCustomer) {
      return NextResponse.json(
        {
          error: "No active subscription found",
          message:
            "There is no active PentestGPT subscription to migrate for this email address.",
        },
        { status: 404 },
      );
    }

    // Determine plan type
    // Default to pro, check for team indicators
    const quantity = pentestGPTSubscription.items.data[0]?.quantity || 1;
    let planType: "pro" | "team" = "pro";
    let interval: "monthly" | "yearly" = "monthly";

    // Check product and price metadata to determine plan type
    const priceId = pentestGPTSubscription.items.data[0]?.price.id;
    if (priceId) {
      const price = await stripe.prices.retrieve(priceId, {
        expand: ["product"],
      });

      const product = price.product;
      let productMetadata = {};
      let productName = "";

      if (typeof product === "object" && product !== null && !product.deleted) {
        productMetadata = product.metadata || {};
        productName = product.name || "";
      }

      // Check multiple indicators for team plan:
      // 1. Price metadata
      // 2. Product metadata
      // 3. Product name
      // Note: Don't check quantity since team plans can have quantity = 1
      const isTeamPlan =
        price.metadata?.plan === "team" ||
        (productMetadata as any).plan === "team" ||
        productName.toLowerCase().includes("team");

      if (isTeamPlan) {
        planType = "team";
      }

      // Determine interval from price
      if ((price.recurring as any)?.interval === "year") {
        interval = "yearly";
      } else if ((price.recurring as any)?.interval === "month") {
        interval = "monthly";
      }
    }

    // Check if user has existing organizations
    const existingMemberships =
      await workos.userManagement.listOrganizationMemberships({
        userId,
      });

    // Delete existing organizations where the user is an admin, regardless of Stripe customer
    if (existingMemberships.data && existingMemberships.data.length > 0) {
      for (const membership of existingMemberships.data) {
        const orgId = membership.organizationId;

        // Determine if the user is an active admin in this organization
        const roleObjSlug: string | undefined = (membership as any)?.role?.slug;
        const rolesArr: Array<{ slug?: string }> | undefined = (
          membership as any
        )?.roles;
        const hasAdminInRoles = Array.isArray(rolesArr)
          ? rolesArr.some((r) => r?.slug === "admin")
          : false;
        const isActive = (membership as any)?.status === "active";
        const isAdmin =
          (roleObjSlug === "admin" || hasAdminInRoles) && isActive;

        if (!isAdmin) {
          continue;
        }

        try {
          await workos.organizations.deleteOrganization(orgId);
        } catch (error) {
          console.error(`Failed to delete organization ${orgId}:`, error);
        }
      }
    }

    // Create new organization with user's email as name
    const organization = await workos.organizations.createOrganization({
      name: user.email,
    });

    // Create organization membership for user as admin
    await workos.userManagement.createOrganizationMembership({
      organizationId: organization.id,
      userId,
      roleSlug: "admin",
    });

    // Update Stripe customer metadata to link to new WorkOS organization
    await stripe.customers.update(pentestGPTCustomer.id, {
      metadata: {
        workOSOrganizationId: organization.id,
        source: "pentestgpt-migrated",
      },
    });

    // Update WorkOS organization with Stripe customer ID
    // This will allow WorkOS to automatically add entitlements to the access token
    await workos.organizations.updateOrganization({
      organization: organization.id,
      stripeCustomerId: pentestGPTCustomer.id,
    });

    // Create new subscription on the linked customer with matching plan and interval
    const allowedPlans = new Set([
      "pro-monthly-plan",
      "pro-yearly-plan",
      "team-monthly-plan",
      "team-yearly-plan",
    ]);

    const subscriptionLookupKey = `${planType}-${interval}-plan` as
      | "pro-monthly-plan"
      | "pro-yearly-plan"
      | "team-monthly-plan"
      | "team-yearly-plan";

    if (!allowedPlans.has(subscriptionLookupKey)) {
      return NextResponse.json(
        { error: `Unsupported plan mapping: ${subscriptionLookupKey}` },
        { status: 400 },
      );
    }

    // Get the destination price by lookup key (must exist in Stripe)
    const destinationPrices = await stripe.prices.list({
      lookup_keys: [subscriptionLookupKey],
      expand: ["data.product"],
    });

    if (!destinationPrices.data || destinationPrices.data.length === 0) {
      console.error(`No price found for lookup key: ${subscriptionLookupKey}`);
      return NextResponse.json(
        { error: "Destination subscription price not found" },
        { status: 404 },
      );
    }

    const destinationPriceId = destinationPrices.data[0].id;

    // Compute optional trial_end based on remaining time on the old subscription
    const nowInSeconds = Math.floor(Date.now() / 1000);
    // Compute trial end using the legacy subscription's period end. Prefer the maximum
    // across subscription items' current_period_end when expanded; fall back to the
    // top-level current_period_end if available.
    const legacy: any = pentestGPTSubscription;
    let computedPeriodEnd: number | undefined = undefined;
    try {
      const items: Array<any> | undefined = legacy?.items?.data;
      if (Array.isArray(items) && items.length > 0) {
        for (const it of items) {
          const endTs: number | undefined = it?.current_period_end;
          if (typeof endTs === "number") {
            computedPeriodEnd = Math.max(computedPeriodEnd ?? 0, endTs);
          }
        }
      }
    } catch {}
    if (!computedPeriodEnd) {
      const topLevelEnd: number | undefined = legacy?.current_period_end;
      if (typeof topLevelEnd === "number") computedPeriodEnd = topLevelEnd;
    }
    const oldCurrentPeriodEnd: number | undefined = computedPeriodEnd;
    const trialEnd =
      typeof oldCurrentPeriodEnd === "number" &&
      oldCurrentPeriodEnd > nowInSeconds
        ? oldCurrentPeriodEnd
        : undefined;

    // Always reuse the old subscription's payment method for the new subscription
    try {
      const legacySub: any = pentestGPTSubscription;
      let paymentMethodId: string | undefined;
      let defaultSourceId: string | undefined;

      // Prefer explicit default on legacy subscription
      if (typeof legacySub.default_payment_method === "string") {
        paymentMethodId = legacySub.default_payment_method as string;
      } else if (legacySub.default_payment_method?.id) {
        paymentMethodId = legacySub.default_payment_method.id as string;
      }

      // Fallback to latest invoice's payment intent method
      if (!paymentMethodId) {
        const maybePM =
          legacySub?.latest_invoice?.payment_intent?.payment_method;
        if (typeof maybePM === "string") {
          paymentMethodId = maybePM as string;
        } else if (maybePM?.id) {
          paymentMethodId = maybePM.id as string;
        }
      }

      // Fallback to customer's default payment method
      if (!paymentMethodId) {
        const custDefaultPm = (pentestGPTCustomer as any)?.invoice_settings
          ?.default_payment_method;
        if (typeof custDefaultPm === "string") {
          paymentMethodId = custDefaultPm as string;
        } else if (custDefaultPm?.id) {
          paymentMethodId = custDefaultPm.id as string;
        }
      }

      // Last resort: legacy default source (for older sources)
      if (!paymentMethodId) {
        const custDefaultSource = (pentestGPTCustomer as any)?.default_source;
        if (typeof custDefaultSource === "string") {
          defaultSourceId = custDefaultSource as string;
        } else if (custDefaultSource?.id) {
          defaultSourceId = custDefaultSource.id as string;
        }
      }

      if (!paymentMethodId && !defaultSourceId) {
        console.error(
          "No reusable payment method found on legacy subscription or customer",
        );
        return NextResponse.json(
          {
            error:
              "No reusable payment method found on legacy subscription or customer",
          },
          { status: 400 },
        );
      }

      // Ensure the payment method is attached to the destination customer
      if (paymentMethodId) {
        try {
          const pm = await stripe.paymentMethods.retrieve(paymentMethodId);
          const attachedCustomer = (pm as any).customer;
          if (!attachedCustomer) {
            await stripe.paymentMethods.attach(paymentMethodId, {
              customer: pentestGPTCustomer.id,
            });
          } else if (attachedCustomer !== pentestGPTCustomer.id) {
            // If attached to another customer, try to attach (Stripe will error if not allowed)
            await stripe.paymentMethods.attach(paymentMethodId, {
              customer: pentestGPTCustomer.id,
            });
          }
        } catch (attachErr) {
          console.warn("Payment method attach attempt result:", attachErr);
        }
      }

      // Set as customer's default to mirror legacy behavior
      if (paymentMethodId) {
        try {
          await stripe.customers.update(pentestGPTCustomer.id, {
            invoice_settings: { default_payment_method: paymentMethodId },
          });
        } catch (custErr) {
          console.warn(
            "Failed setting customer default payment method:",
            custErr,
          );
        }
      }

      // Create the new subscription using the same default payment method
      await stripe.subscriptions.create({
        customer: pentestGPTCustomer.id,
        items: [
          {
            price: destinationPriceId,
            quantity,
          },
        ],
        ...(paymentMethodId ? { default_payment_method: paymentMethodId } : {}),
        ...(defaultSourceId ? { default_source: defaultSourceId } : {}),
        trial_end: trialEnd,
        collection_method: "charge_automatically",
        cancel_at_period_end: false,
      });
    } catch (createErr) {
      console.error("Failed to create destination subscription:", createErr);
      return NextResponse.json(
        { error: "Failed to create destination subscription" },
        { status: 500 },
      );
    }

    // Cancel the old PentestGPT subscription immediately
    try {
      await stripe.subscriptions.cancel(pentestGPTSubscription.id);
    } catch (cancelErr) {
      console.error("Failed to cancel old PentestGPT subscription:", cancelErr);
      // Don't fail the whole migration; proceed
    }

    // Return a minimal response used by the client to decide whether to show team welcome
    const showTeamWelcome = planType === "team" && quantity > 1;
    return NextResponse.json({
      success: true,
      showTeamWelcome,
    });
  } catch (error: unknown) {
    const errorMessage =
      error instanceof Error ? error.message : "An error occurred";
    console.error("Migration error:", errorMessage, error);
    return NextResponse.json({ error: errorMessage }, { status: 500 });
  }
};
