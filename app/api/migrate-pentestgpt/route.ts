import { stripe } from "../stripe";
import { workos } from "../workos";
import { getUserIDAndPro } from "@/lib/auth/get-user-id";
import { NextRequest, NextResponse } from "next/server";

export const POST = async (req: NextRequest) => {
  try {
    console.log("=== Starting PentestGPT Migration ===");

    // Get user ID and subscription status
    const { userId, subscription } = await getUserIDAndPro(req);
    console.log(`User ID: ${userId}, Current subscription: ${subscription}`);

    // Only allow migration if user is on free tier
    if (subscription !== "free") {
      console.log("Migration blocked: User is not on free tier");
      return NextResponse.json(
        {
          error: "Migration not allowed",
          message: "You must be on the free tier to migrate from PentestGPT",
        },
        { status: 400 },
      );
    }

    // Get user details
    const user = await workos.userManagement.getUser(userId);
    console.log(`User email: ${user.email}`);

    // Search for active PentestGPT subscriptions for this email
    const customers = await stripe.customers.list({
      email: user.email,
      limit: 100,
    });
    console.log(`Found ${customers.data.length} Stripe customers for email`);

    let pentestGPTSubscription = null;
    let pentestGPTCustomer = null;

    // Look for customers from old PentestGPT system and active subscriptions
    // Old system used firebaseUID or userId in metadata, new system uses workOSOrganizationId
    for (const customer of customers.data) {
      // Check if customer has old system metadata (firebaseUID or userId) but NOT new system metadata (workOSOrganizationId)
      const hasOldMetadata =
        customer.metadata?.firebaseUID || customer.metadata?.userId;
      const hasNewMetadata = customer.metadata?.workOSOrganizationId;

      console.log(
        `Checking customer ${customer.id}: hasOldMetadata=${!!hasOldMetadata}, hasNewMetadata=${!!hasNewMetadata}`,
      );

      if (hasOldMetadata && !hasNewMetadata) {
        // Check for active subscriptions
        const subscriptions = await stripe.subscriptions.list({
          customer: customer.id,
          status: "active",
          limit: 1,
        });

        console.log(
          `Customer ${customer.id} has ${subscriptions.data.length} active subscriptions`,
        );

        if (subscriptions.data.length > 0) {
          pentestGPTSubscription = subscriptions.data[0];
          pentestGPTCustomer = customer;
          console.log(
            `Found PentestGPT subscription: ${pentestGPTSubscription.id}`,
          );
          break;
        }
      }
    }

    // If no active PentestGPT subscription found
    if (!pentestGPTSubscription || !pentestGPTCustomer) {
      console.log("No active PentestGPT subscription found for migration");
      return NextResponse.json(
        {
          error: "No active subscription found",
          message:
            "There is no active PentestGPT subscription to migrate for this email address.",
        },
        { status: 404 },
      );
    }

    // Determine plan type
    // Default to pro, check for team indicators
    const quantity = pentestGPTSubscription.items.data[0]?.quantity || 1;
    let planType: "pro" | "team" = "pro";
    let interval: "monthly" | "yearly" = "monthly";

    console.log(`Subscription quantity: ${quantity}`);

    // Check product and price metadata to determine plan type
    const priceId = pentestGPTSubscription.items.data[0]?.price.id;
    if (priceId) {
      const price = await stripe.prices.retrieve(priceId, {
        expand: ["product"],
      });

      console.log(`Price ID: ${priceId}`);
      console.log(`Price metadata:`, price.metadata);

      const product = price.product;
      let productMetadata = {};
      let productName = "";

      if (typeof product === "object" && product !== null && !product.deleted) {
        productMetadata = product.metadata || {};
        productName = product.name || "";
        console.log(`Product name: ${productName}`);
        console.log(`Product metadata:`, productMetadata);
      }

      // Check multiple indicators for team plan:
      // 1. Price metadata
      // 2. Product metadata
      // 3. Product name
      // Note: Don't check quantity since team plans can have quantity = 1
      const isTeamPlan =
        price.metadata?.plan === "team" ||
        (productMetadata as any).plan === "team" ||
        productName.toLowerCase().includes("team");

      if (isTeamPlan) {
        planType = "team";
      }

      // Determine interval from price
      if ((price.recurring as any)?.interval === "year") {
        interval = "yearly";
      } else if ((price.recurring as any)?.interval === "month") {
        interval = "monthly";
      }
    }

    console.log(`Determined plan type: ${planType}, interval: ${interval}`);

    // Check if user has existing organizations
    const existingMemberships =
      await workos.userManagement.listOrganizationMemberships({
        userId,
      });

    console.log(
      `User has ${existingMemberships.data?.length || 0} existing organization memberships`,
    );

    // Delete existing organizations if any
    if (existingMemberships.data && existingMemberships.data.length > 0) {
      for (const membership of existingMemberships.data) {
        const orgId = membership.organizationId;

        try {
          // Get organization details
          const org = await workos.organizations.getOrganization(orgId);

          // If the org has a different Stripe customer, don't interfere with it
          if (
            org.stripeCustomerId &&
            org.stripeCustomerId !== pentestGPTCustomer.id
          ) {
            console.log(
              `Organization ${orgId} has a different Stripe customer (${org.stripeCustomerId}), skipping deletion`,
            );
            continue;
          }

          // Delete the organization
          console.log(`Deleting organization: ${orgId}`);
          await workos.organizations.deleteOrganization(orgId);
          console.log(`Successfully deleted organization: ${orgId}`);
        } catch (error) {
          console.error(`Failed to delete organization ${orgId}:`, error);
        }
      }
    }

    // Create new organization with user's email as name
    console.log(`Creating new organization for: ${user.email}`);
    const organization = await workos.organizations.createOrganization({
      name: user.email,
    });
    console.log(`Created organization: ${organization.id}`);

    // Create organization membership for user as admin
    console.log(`Creating organization membership for user as admin`);
    await workos.userManagement.createOrganizationMembership({
      organizationId: organization.id,
      userId,
      roleSlug: "admin",
    });
    console.log(`Organization membership created`);

    // Update Stripe customer metadata to link to new WorkOS organization
    console.log(`Updating Stripe customer ${pentestGPTCustomer.id} metadata`);
    await stripe.customers.update(pentestGPTCustomer.id, {
      metadata: {
        workOSOrganizationId: organization.id,
        source: "pentestgpt-migrated",
      },
    });
    console.log(`Stripe customer metadata updated`);

    // Update WorkOS organization with Stripe customer ID
    // This will allow WorkOS to automatically add entitlements to the access token
    console.log(`Linking WorkOS organization to Stripe customer`);
    await workos.organizations.updateOrganization({
      organization: organization.id,
      stripeCustomerId: pentestGPTCustomer.id,
    });
    console.log(`WorkOS organization updated with Stripe customer ID`);

    console.log("=== Migration completed successfully ===");
    console.log(`Plan: ${planType}, Organization: ${organization.id}`);

    // Create new subscription on the linked customer with matching plan and interval
    const allowedPlans = new Set([
      "pro-monthly-plan",
      "pro-yearly-plan",
      "team-monthly-plan",
      "team-yearly-plan",
    ]);

    const subscriptionLookupKey = `${planType}-${interval}-plan` as
      | "pro-monthly-plan"
      | "pro-yearly-plan"
      | "team-monthly-plan"
      | "team-yearly-plan";

    if (!allowedPlans.has(subscriptionLookupKey)) {
      return NextResponse.json(
        { error: `Unsupported plan mapping: ${subscriptionLookupKey}` },
        { status: 400 },
      );
    }

    // Get the destination price by lookup key (must exist in Stripe)
    const destinationPrices = await stripe.prices.list({
      lookup_keys: [subscriptionLookupKey],
      expand: ["data.product"],
    });

    if (!destinationPrices.data || destinationPrices.data.length === 0) {
      console.error(`No price found for lookup key: ${subscriptionLookupKey}`);
      return NextResponse.json(
        { error: "Destination subscription price not found" },
        { status: 404 },
      );
    }

    const destinationPriceId = destinationPrices.data[0].id;

    // Compute optional trial_end based on remaining time on the old subscription
    const nowInSeconds = Math.floor(Date.now() / 1000);
    const oldCurrentPeriodEnd: number | undefined = (pentestGPTSubscription as any)
      .current_period_end;
    const trialEnd =
      typeof oldCurrentPeriodEnd === "number" && oldCurrentPeriodEnd > nowInSeconds
        ? oldCurrentPeriodEnd
        : undefined;

    // Create the new subscription first (with optional trial)
    try {
      await stripe.subscriptions.create({
        customer: pentestGPTCustomer.id,
        items: [
          {
            price: destinationPriceId,
            quantity,
          },
        ],
        trial_end: trialEnd,
        collection_method: "charge_automatically",
        cancel_at_period_end: false,
      });
    } catch (createErr) {
      console.error("Failed to create destination subscription:", createErr);
      return NextResponse.json(
        { error: "Failed to create destination subscription" },
        { status: 500 },
      );
    }

    // Cancel the old PentestGPT subscription immediately
    try {
      await stripe.subscriptions.cancel(pentestGPTSubscription.id);
    } catch (cancelErr) {
      console.error("Failed to cancel old PentestGPT subscription:", cancelErr);
      // Don't fail the whole migration; proceed
    }

    // Return a minimal response used by the client to decide whether to show team welcome
    const showTeamWelcome = planType === "team" && quantity > 1;
    return NextResponse.json({
      success: true,
      showTeamWelcome,
    });
  } catch (error: unknown) {
    const errorMessage =
      error instanceof Error ? error.message : "An error occurred";
    console.error("Migration error:", errorMessage, error);
    return NextResponse.json({ error: errorMessage }, { status: 500 });
  }
};
